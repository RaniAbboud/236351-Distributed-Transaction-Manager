package zookeeper;

import com.google.common.hash.Hashing;
import constants.Constants;
import javassist.bytecode.stackmap.TypeData;
import javassist.expr.NewArray;
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.Stat;
import org.springframework.util.SerializationUtils;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

class NodeData implements Serializable {
    private String address;
    private Boolean vote = null;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public Boolean getVote() {
        return vote;
    }

    public void setVote(boolean vote) {
        this.vote = vote;
    }

    public NodeData(boolean vote) {
        this.setVote(vote);
    }

    public NodeData(String address) {
        this.setAddress(address);
    }
}

public class ZooKeeperClientImpl implements ZooKeeperClient {
    private static final Logger LOGGER = Logger.getLogger(TypeData.ClassName.class.getName());
    private ZooKeeper zk;
    private String serverId;
    private HashMap<String, Integer> locks = new HashMap<>();
    final private int sessionTimeout = 5000;
    final private String shardsPath = "/shards";
    final private String serversPath = "/servers";
    final private String barriersPath = "/barriers";
    final private String counterPath = "/counter";
    final private String atomicTransactionsPath = "/atomic-transactions";

    /**
     * Constructor.
     *
     * @param zkConnection: comma-separated list of host:port pairs, each corresponding to a ZooKeeper server.
     * @throws IOException
     */
    public ZooKeeperClientImpl(String zkConnection) throws IOException {
        this.zk = new ZooKeeper(zkConnection, sessionTimeout, null); // todo: watcher?
    }

    private Watcher createWatcher(String id) {
        class IdWatcher implements Watcher {
            @Override
            public void process(WatchedEvent event) {
                Integer mutex = locks.get(id);
                synchronized (mutex) {
                    mutex.notify();
                }
            }
        }
        return new IdWatcher();
    }

    /**
     * @return Returns all shard ids sorted
     * @throws InterruptedException
     * @throws KeeperException
     */
    public List<String> getAllShards() throws InterruptedException, KeeperException {
        List<String> shards = zk.getChildren(shardsPath, null); // we don't need a watch here so watcher=null
        Collections.sort(shards);
        return shards;
    }

    private static int getNumberOfShardsEnvVar() {
        return Integer.parseInt(System.getenv(Constants.ENV_NUM_SHARDS));
    }

    private List<String> getServersInShard(String shardId) throws InterruptedException, KeeperException {
        final String shardPath = shardsPath + "/" + shardId;
        List<String> serversInShard = zk.getChildren(shardPath, null); // we don't need a watch here so watcher=null
        Collections.sort(serversInShard);
        return serversInShard;
    }

    /**
     * @param serverId: the server's ID including the unique suffix generated by ZooKeeper.
     * @return shardId: the shard's ID
     * @throws InterruptedException
     * @throws KeeperException
     */
    private String getShardForServer(String serverId) throws InterruptedException, KeeperException {
        String serverIndexStr = serverId.replaceFirst("^.*server-", "");
        int serverIndex = Integer.parseInt(serverIndexStr); // The indexes start from 0
        return getAllShards().get(serverIndex / getNumberOfShardsEnvVar());
    }

    /**
     * Registers the servers to the /servers and to the /shards/:shardId/ structures.
     * This method should be called after these structured where initialised.
     *
     * @param address: the server's address
     * @return the serverId
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String registerServer(String address) throws InterruptedException, KeeperException {
        NodeData serverNodeData = new NodeData(address);
        String serverId = zk.create(serversPath + "/server-", SerializationUtils.serialize(serverNodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        serverId = serverId.replaceFirst("^.*server-", "server-");
        this.serverId = serverId;
        // Register to /shards/:shardId/
        String shardId = getShardForServer(serverId);
        zk.create(shardsPath + "/" + shardId + "/" + serverId, SerializationUtils.serialize(serverNodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        return serverId;
    }

    @Override
    public void enterBarrier(String barrierId, String[] shards) throws KeeperException, InterruptedException {
        String barrierPath = barriersPath + "/" + barrierId;
//        Stat s = zk.exists(barrierPath, false);
//        if (s == null) {
        this.locks.put(barrierId, 1); // create a mutex for this barrier
        try {
            zk.create(barrierPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
        } catch (KeeperException.NodeExistsException e) {
            LOGGER.log(Level.FINEST, "Not creating barrier node. Barrier node already exists. BarrierId=" + barrierId);
            // already exists, ignore error.
        }
//        }
        // create node representing the server as a child of the barrier node
        zk.create(barrierPath + "/" + serverId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        while (true) {
            synchronized (locks.get(barrierId)) {
                List<String> list = zk.getChildren(barrierPath, createWatcher(barrierId)); // setting a watcher for this specific barrierId
                // get the number of server participating in the barrier
                int serversCount = 0;
                for (String shard : shards) {
                    serversCount += getServersInShard(shard).size();
                }
                if (list.size() < serversCount) {
                    locks.get(barrierId).wait();
                } else {
                    return;
                }
            }
        }
    }

    @Override
    public void leaveBarrier(String barrierId, String[] shards) throws InterruptedException, KeeperException {
        try {
            zk.delete(barriersPath + "/" + barrierId + "/" + serverId, -1);
        } catch (KeeperException.NoNodeException e) {
            LOGGER.log(Level.FINEST, "Barrier child node already deleted. BarrierId=" + barrierId + " ServerId=" + serverId);
            // already deleted, ignore error.
        }
        while (true) {
            synchronized (locks.get(barrierId)) {
                List<String> list = zk.getChildren(barriersPath + "/" + barrierId, createWatcher(barrierId));
                if (list.size() > 0) {
                    locks.get(barrierId).wait();
                } else {
                    try {
                        zk.delete(barriersPath + "/" + barrierId, -1);
                    } catch (KeeperException.NoNodeException e) {
                        LOGGER.log(Level.FINEST, "Barrier node already deleted. BarrierId=" + barrierId);
                        // already deleted, ignore error.
                    }
                    return;
                }
            }
        }
    }

    /**
     * getResponsibleShard uses consistentHash to find the shard responsible for the client's address.
     *
     * @param address: the client's address
     * @return the shardId responsible for the client's address
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String getResponsibleShard(String address) throws InterruptedException, KeeperException {
        List<String> shards = getAllShards();
        int bucket = Hashing.consistentHash(address.hashCode(), shards.size());
        return shards.get(bucket);
    }

    /**
     * getShardLeader returns the leader of the shard by choosing the server with the minimal ID under the given shard.
     *
     * @param shardId
     * @return
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String getShardLeader(String shardId) throws InterruptedException, KeeperException {
        List<String> shardServers = getServersInShard(shardId);
        return Collections.min(shardServers);
    }

    @Override
    public boolean atomicCommitWait(String atomicTxnListId, boolean vote, String[] shards) throws InterruptedException, KeeperException {
        String myShardId = getShardForServer(serverId);
        String atomicTxnListPath = atomicTransactionsPath + "/" + atomicTxnListId;
        // create node representing this atomic transactions list
        try {
            zk.create(atomicTxnListPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
        } catch (KeeperException.NodeExistsException e) {
            LOGGER.log(Level.FINEST, "Not creating atomic list node. Atomic list node already exists. Atomic transaction list id =" + atomicTxnListId);
            // already exists, ignore error.
        }
        // create node representing my shard's vote for this atomic list
        try {
            NodeData nodeData = new NodeData(vote);
            zk.create(atomicTxnListPath + "/" + myShardId, SerializationUtils.serialize(nodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
        } catch (KeeperException.NodeExistsException e) {
            LOGGER.log(Level.FINEST, "Not creating shard node for this atomic list. Shard node already exists. Atomic transaction list id =" + atomicTxnListId);
            // already exists, ignore error.
        }
        /* Enter Barrier */
        enterBarrier(atomicTxnListId, shards);

        List<String> votingShards = zk.getChildren(atomicTxnListPath, null);
        List<Boolean> votes = new ArrayList<>();
        for (String shard : votingShards) {
            // read shard vote
            byte[] data = zk.getData(atomicTxnListPath + "/" + shard, false, null);
            NodeData nodeData = (NodeData) SerializationUtils.deserialize(data);
            assert nodeData != null;
            votes.add(nodeData.getVote());
        }
        /* Leave Barrier */
        leaveBarrier(atomicTxnListId, shards);
        return votes.stream().allMatch(val -> val);
    }

    /**
     * watchLeader is used by the atomic-broadcast to get notified when the leader needs to be changed.
     *
     * @param shardId
     * @param func
     */
    @Override
    public void watchLeader(String shardId, Method func) {
        class LeaderWatcher implements Watcher {
            @Override
            public void process(WatchedEvent event) {
                // leader may have changed
                try {
                    // set the watcher again (since it's a one-time trigger)
                    List<String> serversInShard = zk.getChildren(shardsPath + "/" + shardId, new LeaderWatcher());
                    func.invoke(null);
                } catch (IllegalAccessException | InvocationTargetException e) {
                    LOGGER.log(Level.SEVERE, "Failed to call leader-watcher method for shard " + shardId, e);
                } catch (InterruptedException | KeeperException e) {
                    LOGGER.log(Level.SEVERE, "Failed to reset watcher on leader for shard " + shardId, e);
                }
            }
        }
        // set the initial watch
        try {
            List<String> serversInShard = zk.getChildren(shardsPath + "/" + shardId, new LeaderWatcher());
        } catch (KeeperException | InterruptedException e) {
            LOGGER.log(Level.SEVERE, "Failed to set watcher on leader for shard " + shardId, e);
        }
    }

    /**
     * @return A new unique timestamp as int.
     */
    @Override
    public int getTimestamp() {
        // create sequential node
        int index = 0;
        String indexStr = "";
        try {
            String id = zk.create(counterPath + "/child-", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            indexStr = id.replaceFirst("^.*child-", "");
            index = Integer.parseInt(indexStr) - 1; // I think the indexes start from 1 and not 0. That's why I did -1.
        } catch (KeeperException | InterruptedException e) {
            LOGGER.log(Level.SEVERE, "Failed to create counter node", e);
            return -1;
        }

        try {
            zk.delete(counterPath + "/child-" + indexStr, 0);
        } catch (InterruptedException | KeeperException e) {
            LOGGER.log(Level.WARNING, "Failed to delete counter node after generating timestamp. Node path: " + counterPath + "/child-" + indexStr, e);
        }

        return index;
    }

    @Override
    public void setupInitialStructures() throws InterruptedException, KeeperException {
        // Create root path ("/")
        final String rootPath = "/";
        Stat stat = zk.exists(rootPath, false);
        if (stat == null) {
            zk.create(rootPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        // Create servers path ("/servers")
        stat = zk.exists(serversPath, false);
        if (stat == null) {
            zk.create(serversPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        // Create shards path ("/shards")
        stat = zk.exists(shardsPath, false);
        if (stat == null) {
            zk.create(shardsPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        // Create barriers path ("/barriers")
        stat = zk.exists(barriersPath, false);
        if (stat == null) {
            zk.create(barriersPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        // Create counter path ("/counter")
        stat = zk.exists(counterPath, false);
        if (stat == null) {
            zk.create(counterPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }
        // Create shard nodes ("/shards/:shardId")
        for (int i = 0; i < getNumberOfShardsEnvVar(); i++) {
            try {
                zk.create(shardsPath + "/shard-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } catch (KeeperException.NodeExistsException e) {
                LOGGER.log(Level.FINEST, "Not creating shard node. Node already exists. ShardId=shard-"+i);
            }
        }
    }

    @Override
    public String getServerAddress(String serverId) throws InterruptedException, KeeperException {
        byte[] data = zk.getData(serversPath + "/" + serverId, false, null);
        NodeData nodeData = (NodeData) SerializationUtils.deserialize(data);
        assert nodeData != null;
        return nodeData.getAddress();
    }
}
