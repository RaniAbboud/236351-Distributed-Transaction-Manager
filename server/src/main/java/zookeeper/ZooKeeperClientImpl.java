package zookeeper;

import com.google.common.hash.Hashing;
import constants.Constants;
import javassist.bytecode.stackmap.TypeData;
import org.apache.zookeeper.*;
import org.apache.zookeeper.data.ACL;
import org.apache.zookeeper.data.Stat;
import org.springframework.util.SerializationUtils;

import java.io.IOException;
import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

class NodeData implements Serializable {
    private String address;
    private Boolean decision = null;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public Boolean getDecision() {
        return decision;
    }

    public void setDecision(boolean decision) {
        this.decision = decision;
    }

    public NodeData(boolean decision) {
        this.decision = decision;
    }

    public NodeData(String address) {
        this.setAddress(address);
    }
}

public class ZooKeeperClientImpl implements ZooKeeperClient {
    private static final Logger LOGGER = Logger.getLogger(TypeData.ClassName.class.getName());
    private String zkConnection;
    private ZooKeeper zk;
    private String serverId;
    private final HashMap<String, Integer> locks = new HashMap<>();
    final private String shardsPath = "/shards";
    final private String serversPath = "/servers";
    final private String barriersPath = "/barriers";
    final private String counterPath = "/counter";

    public ZooKeeperClientImpl(String zkConnection) {
        this.zkConnection = zkConnection;
    }
    public ZooKeeperClientImpl() {
        this(System.getenv(Constants.ENV_ZK_CONNECTION));
    }


    private Watcher createWatcher(String id, Watcher.Event.EventType eventType) {
        class IdWatcher implements Watcher {
            @Override
            public void process(WatchedEvent event) {
                Integer mutex = locks.get(id);
                synchronized (mutex) {
                    if (eventType == null || eventType == event.getType()){
                        mutex.notify();
                    }
                }
            }
        }
        return new IdWatcher();
    }

    /**
     * @return Returns all shard ids sorted
     * @throws InterruptedException
     * @throws KeeperException
     */
    public List<String> getAllShards() throws InterruptedException, KeeperException {
        List<String> shards = zk.getChildren(shardsPath, null); // we don't need a watch here so watcher=null
        Collections.sort(shards);
        return shards;
    }

    private static int getNumberOfShardsEnvVar() {
        return Integer.parseInt(System.getenv(Constants.ENV_NUM_SHARDS));
    }

    private List<String> getServersInShard(String shardId) throws InterruptedException, KeeperException {
        final String shardPath = shardsPath + "/" + shardId;
        List<String> serversInShard = zk.getChildren(shardPath, null); // we don't need a watch here so watcher=null
        Collections.sort(serversInShard);
        return serversInShard;
    }

    /**
     * @param serverId: the server's ID including the unique suffix generated by ZooKeeper.
     * @return shardId: the shard's ID
     * @throws InterruptedException
     * @throws KeeperException
     */
    private String getShardForServer(String serverId) throws InterruptedException, KeeperException {
        String serverIndexStr = serverId.replaceFirst("^.*server-", "");
        int serverIndex = Integer.parseInt(serverIndexStr); // The indexes start from 0
        return getAllShards().get(serverIndex / getNumberOfShardsEnvVar());
    }

    /**
     * Setup for the Zookeeper
     * Called first when a server first starts.
     * Needs to wait until all servers in the system are up and running before returning
     */
    @Override
    public void setup() throws IOException {
        // FIXME: Need to setup everything here

        // Create Client
        int sessionTimeout = 5000;
        this.zk = new ZooKeeper(zkConnection, sessionTimeout, null); // todo: watcher?
    }

    @Override
    public void setupInitialStructures() throws InterruptedException, KeeperException {
        // Create root path ("/")
        createNodeIfNotExists("/", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        // Create servers path ("/servers")
        createNodeIfNotExists(serversPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        // Create shards path ("/shards")
        createNodeIfNotExists(shardsPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        // Create barriers path ("/barriers")
        createNodeIfNotExists(barriersPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        // Create counter path ("/counter")
        createNodeIfNotExists(counterPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        // Create shard nodes ("/shards/:shardId")
        for (int i = 0; i < getNumberOfShardsEnvVar(); i++) {
            try {
                zk.create(shardsPath + "/shard-" + i, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
            } catch (KeeperException.NodeExistsException e) {
                LOGGER.log(Level.FINEST, "Not creating shard node. Node already exists. ShardId=shard-"+i);
            }
        }
    }

    /**
     * Registers the servers to the /servers and to the /shards/:shardId/ structures.
     * This method should be called after these structured where initialised.
     *
     * @param address: the server's address
     * @return the serverId
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String registerServer(String address) throws InterruptedException, KeeperException {
        NodeData serverNodeData = new NodeData(address);
        String serverId = zk.create(serversPath + "/server-", SerializationUtils.serialize(serverNodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        serverId = serverId.replaceFirst("^.*server-", "server-");
        this.serverId = serverId;
        // Register to /shards/:shardId/
        String shardId = getShardForServer(serverId);
        zk.create(shardsPath + "/" + shardId + "/" + serverId, SerializationUtils.serialize(serverNodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        return serverId;
    }

    /**
     * Wait for a decision for the atomic-list operation. "Are we doing it or not?"
     * @param barrierId The barrier ID for the barrier to watch the atomic-transactions-list's decision.
     * @param initiatorServerId The server ID of the server that is responsible for the atomic list request.
     *                         If this server fails, we will exit the wait.
     */
    @Override
    public void waitForDecision(String barrierId, String initiatorServerId) throws Exception {
        String watchId = barrierId + "-decision"; // setting a different watchId than the one we're using for the barrier itself.
        this.locks.put(watchId, 1); // create a mutex for this watch
        watchServer(initiatorServerId, watchId);
        Stat stat = zk.exists(barriersPath + "/" + barrierId, createWatcher(watchId, Watcher.Event.EventType.NodeDataChanged));
        if (stat == null) {
            throw new Exception("Failed to set watch on barrier node data: node doesn't exist.");
        }
    }

    /**
     * Sets the decision for the given barrier. The "other" servers will be using the waitForDecision method to wait until
     * the decision is set.
     * @param barrierId: The barrier ID for the barrier corresponding to the relevant atomic-transactions-list operation
     * @param decision: The decision (boolean).
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public void setDecision(String barrierId, boolean decision) throws InterruptedException, KeeperException {
        zk.setData(barriersPath + "/" + barrierId, SerializationUtils.serialize(new NodeData(decision)), -1);
    }

    @Override
    public void enterBarrier(String barrierId, String[] shards) throws KeeperException, InterruptedException {
        String barrierPath = barriersPath + "/" + barrierId;
        this.locks.put(barrierId, 1); // create a mutex for this barrier
        try {
            zk.create(barrierPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
        } catch (KeeperException.NodeExistsException e) {
            LOGGER.log(Level.FINEST, "Not creating barrier node. Barrier node already exists. BarrierId=" + barrierId);
            // already exists, ignore error.
        }
        // create node representing the server as a child of the barrier node
        zk.create(barrierPath + "/" + serverId, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        while (true) {
            synchronized (locks.get(barrierId)) {
                List<String> list = zk.getChildren(barrierPath, createWatcher(barrierId, Watcher.Event.EventType.NodeChildrenChanged)); // setting a watcher for this specific barrierId
                // get the number of servers participating in the barrier
                int serversCount = 0;
                for (String shard : shards) {
                    serversCount += getServersInShard(shard).size();
                }
                if (list.size() < serversCount) {
                    locks.get(barrierId).wait();
                } else {
                    return;
                }
            }
        }
    }

    @Override
    public void leaveBarrier(String barrierId, String[] shards) throws InterruptedException, KeeperException {
        try {
            zk.delete(barriersPath + "/" + barrierId + "/" + serverId, -1);
        } catch (KeeperException.NoNodeException e) {
            LOGGER.log(Level.FINEST, "Barrier child node already deleted. BarrierId=" + barrierId + " ServerId=" + serverId);
            // already deleted, ignore error.
        }
        while (true) {
            synchronized (locks.get(barrierId)) {
                List<String> list = zk.getChildren(barriersPath + "/" + barrierId, createWatcher(barrierId, Watcher.Event.EventType.NodeChildrenChanged));
                if (list.size() > 0) {
                    locks.get(barrierId).wait();
                } else {
                    try {
                        zk.delete(barriersPath + "/" + barrierId, -1);
                    } catch (KeeperException.NoNodeException e) {
                        LOGGER.log(Level.FINEST, "Barrier node already deleted. BarrierId=" + barrierId);
                        // already deleted, ignore error.
                    }
                    return;
                }
            }
        }
    }

    /**
     * getResponsibleShard uses consistentHash to find the shard responsible for the client's address.
     *
     * @param address: the client's address
     * @return the shardId responsible for the client's address
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String getResponsibleShard(String address) throws InterruptedException, KeeperException {
        List<String> shards = getAllShards();
        int bucket = Hashing.consistentHash(address.hashCode(), shards.size());
        return shards.get(bucket);
    }

    /**
     * getShardLeader returns the leader of the shard by choosing the server with the minimal ID under the given shard.
     *
     * @param shardId
     * @return
     * @throws InterruptedException
     * @throws KeeperException
     */
    @Override
    public String getShardLeader(String shardId) throws InterruptedException, KeeperException {
        List<String> shardServers = getServersInShard(shardId);
        return Collections.min(shardServers);
    }

//    @Override
//    public boolean atomicCommitWait(String atomicTxnListId, boolean vote, String[] shards) throws InterruptedException, KeeperException {
//        String myShardId = getShardForServer(serverId);
//        String atomicTransactionsPath = "/atomic-transactions";
//        String atomicTxnListPath = atomicTransactionsPath + "/" + atomicTxnListId;
//        // create node representing this atomic transactions list
//        try {
//            zk.create(atomicTxnListPath, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
//        } catch (KeeperException.NodeExistsException e) {
//            LOGGER.log(Level.FINEST, "Not creating atomic list node. Atomic list node already exists. Atomic transaction list id =" + atomicTxnListId);
//            // already exists, ignore error.
//        }
//        // create node representing my shard's vote for this atomic list
//        try {
//            NodeData nodeData = new NodeData();
//            zk.create(atomicTxnListPath + "/" + myShardId, SerializationUtils.serialize(nodeData), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); // create the barrier node
//        } catch (KeeperException.NodeExistsException e) {
//            LOGGER.log(Level.FINEST, "Not creating shard node for this atomic list. Shard node already exists. Atomic transaction list id =" + atomicTxnListId);
//            // already exists, ignore error.
//        }
//        /* Enter Barrier */
//        enterBarrier(atomicTxnListId, shards);
//
//        List<String> votingShards = zk.getChildren(atomicTxnListPath, null);
//        List<Boolean> votes = new ArrayList<>();
//        for (String shard : votingShards) {
//            // read shard vote
//            byte[] data = zk.getData(atomicTxnListPath + "/" + shard, false, null);
//            NodeData nodeData = (NodeData) SerializationUtils.deserialize(data);
//            assert nodeData != null;
//            votes.add(nodeData.getDecision());
//        }
//        /* Leave Barrier */
//        leaveBarrier(atomicTxnListId, shards);
//        return votes.stream().allMatch(val -> val);
//    }

    private void watchServer(String serverId, String watchId) throws Exception {
        Stat stat = zk.exists(serversPath + "/" + serverId, createWatcher(watchId, Watcher.Event.EventType.NodeDeleted));
        if (stat == null) {
            throw new Exception("Failed to set watch on server: server is probably dead.");
        }
    }

    /**
     * watchLeader is used by the atomic-broadcast to get notified when the leader needs to be changed.
     *
     * @param shardId
     * @param func
     */
    @Override
    public void watchLeader(String shardId, Method func) {
        class LeaderWatcher implements Watcher {
            @Override
            public void process(WatchedEvent event) {
                // leader may have changed
                try {
                    // set the watcher again (since it's a one-time trigger)
                    List<String> serversInShard = zk.getChildren(shardsPath + "/" + shardId, new LeaderWatcher());
                    func.invoke(null);
                } catch (IllegalAccessException | InvocationTargetException e) {
                    LOGGER.log(Level.SEVERE, "Failed to call leader-watcher method for shard " + shardId, e);
                } catch (InterruptedException | KeeperException e) {
                    LOGGER.log(Level.SEVERE, "Failed to reset watcher on leader for shard " + shardId, e);
                }
            }
        }
        // set the initial watch
        try {
            List<String> serversInShard = zk.getChildren(shardsPath + "/" + shardId, new LeaderWatcher());
        } catch (KeeperException | InterruptedException e) {
            LOGGER.log(Level.SEVERE, "Failed to set watcher on leader for shard " + shardId, e);
        }
    }

    /**
     * @return A new unique timestamp as int.
     */
    @Override
    public int getTimestamp() {
        // create sequential node
        int index = 0;
        String indexStr = "";
        try {
            String id = zk.create(counterPath + "/child-", new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
            indexStr = id.replaceFirst("^.*child-", "");
            index = Integer.parseInt(indexStr) - 1; // I think the indexes start from 1 and not 0. That's why I did -1.
        } catch (KeeperException | InterruptedException e) {
            LOGGER.log(Level.SEVERE, "Failed to create counter node", e);
            return -1;
        }

        try {
            zk.delete(counterPath + "/child-" + indexStr, 0);
        } catch (InterruptedException | KeeperException e) {
            LOGGER.log(Level.WARNING, "Failed to delete counter node after generating timestamp. Node path: " + counterPath + "/child-" + indexStr, e);
        }

        return index;
    }

    private void createNodeIfNotExists(String path, byte[] data, List<ACL> acl, CreateMode createMode) throws InterruptedException, KeeperException {
        Stat stat = zk.exists(path, false);
        if (stat == null) {
            zk.create(path, data, acl, createMode);
        }
    }


    @Override
    public String getServerAddress(String serverId) throws InterruptedException, KeeperException {
        byte[] data = zk.getData(serversPath + "/" + serverId, false, null);
        NodeData nodeData = (NodeData) SerializationUtils.deserialize(data);
        assert nodeData != null;
        return nodeData.getAddress();
    }
}
